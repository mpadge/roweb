One of the major categories for ROpenSci packages is data access, and there are many packages for accessing a bewildering array of data. Befitting the "Sci" emphasis, most of these provide access to what might be called "scientific data" - that is, data collected using standardised and widely accepted scientific equipment and methods. RopenSci curates and hosts packages for accessing scientific data from ecological, genomic, hydrological, and climatic sources, along with several packages explicitly devoted to accessing geospatial data. There are also packages for accessing more general data not necessarily collected using recognised "scientific" methodologies, notably including textual, historical, and political data, and a few more esoteric packages for extracting data from patents and from crypto-currency exchanges.

Interested users of such data are rarely likely to have contributed to the actual data. This is primarily because most scientific data are abstract, yet even the directly human-generated data such as textual, historical, or political data are unlikely to have been generated by potential users of those data. Perhaps the only exception are crypto-currency exchange data provided by the `bittrex` package. Users of this package can contribute to the data directly through exchanging crypto-currencies, yet even this is likely to remain a minority pursuit.

One new ROpenSci package provides access to data to which users may already have directly contributed. Moreover, contribution is fun, keeps you fit, and helps made the world a better place. The data come from using public bicycle hire schemes, and the package is called `bikedata`. Public bicycle hire systems operate in many cities throughout the world, and most systems collect (generally anonymous) data, minimally consisting of the times and locations at which every single bicycle trip starts and ends. The `bikedata` package provides access to data from all cities which openly publish these data, currently including London, U.K., and in the U.S.A., New York, Los Angeles, Philadelphia, Chicago, Boston, and Washington DC.

Why bikedata?
=============

The short answer to that question is that the package provides access to what is arguably one of the most spatially and temporally detailed databases of finely-scaled human movement throughout several of the world's most important cities. Such data are likely to prove invaluable in the increasingly active and well-funded attempt to develop a science of cities. Such a science does not yet exist in any way comparable to most other well-established scientific disciplines, but the importance of developing a science of cities is indisputable, and reflected in such enterprises as the [Center for Urban Science and Progress](http://cusp.nyu.edu).

Cities are only cities because people move through them, yet at present anyone faced with the seemingly fundamental question of how, when, and where people move through cities would likely have to draw on some form of private data (typically operators of transport systems or mobile phone providers). There are very few public data providing insight into this question. The data accessed by the `bikedata` package are constantly updated, typically on a monthly basis, and the package thus provides ongoing insight into the dynamic changes and reconfigurations of these cities. Data currently available via the package amounts to several tens of Gigabytes, and will expand rapidly both with time, and with the addition of more cities to the package.

How it works
============

The package currently focusses on the data alone, and provides functionality for downloading, storage, and aggregation. The data are stored in an `SQLite3` database, enabling newly published data to be continually added, generally with one simple line of code. It's as easy as this:

``` r
store_bikedata (city = "chicago", bikedb = "bikedb")
```

If the nominated database (`bikedb`) already holds data for Chicago, only new data will be added, otherwise all historical data will be downloaded and added.

All bicycle hire systems accessed by `bikedata` have fixed docking stations, and the primary means of aggregation is in terms of "trip matrices", which are square matrices of numbers of trips between all pairs of stations, extracted with:

``` r
tm <- bike_tripmat (bikedb = "bikedb", city = "chicago")
```

If the database only contains data for Chicago, the `city` parameter may be omitted. Trip matrices may be filtered by time (through entirely flexible combinations of year, month, day, hour, minute, or even second), as well as by demographic characteristics such as gender or date of birth for those systems which provide such data. (These data are freely provided by users of the systems, and there can be no guarantee of their accuracy.) Examples are:

``` r
tm <- bike_tripmat ("bikedb", start_date = 20160101, end_date = "16,02,28",
                 start_time = 6, end_time = 24,
                 birth_year = 1980:1990, gender = "f")
```

The second mode of aggregation is as daily time series, via the `bike_daily_trips()` function.

What can be done with these data?
=================================

Lots of things. How about examining how far people ride. This requires getting the distances between all pairs of docking stations as routed through the street network, to yield a distance matrix corresponding to the trip matrix. Fortunately, a new R package has just been released to perform exactly that task. It's called [`dodgr`](https://cran.r-project.org/package=dodgr) (Distances on Directed Graphs). (Disclaimer: It's my package, and this is a shameless plug for it - please use it!) Calculating distance matrices is as easy as,

``` r
library (dodgr)
stations <- bike_stations ("bikedb", city = "chicago")
index <- match (rownames (tmat), stations$stn_id)
xy <- stations [index, which (names (stations) %in% c ("longitude", "latitude"))]
dmat <- dodgr_dists (from = xy, to = xy, quiet = FALSE)
```

    ## No graph submitted to dodgr_dists; downloading street network ...  done
    ## Converting network to dodgr graph ... done
    ## Calculating shortest paths ... done.

Trip matrices may not include all stations listed by a given system, so the `index` ensures that the station coordinates match the trip matrix. This function may take a couple of minutes to execute, mostly because it works by first downloading the entire street network encompassing those stations (using the ROpenSci package `osmdata`). The actual routing throughout the network is relatively quick.

Distances can then be visually related to trip numbers to reveal their distributional form. These matrices contain too many values to plot directly, so the `hexbin` package is used here to aggregate in a `ggplot`.

``` r
library (hexbin)
library (ggplot2)
dat <- data.frame (d = as.vector (dmat_ch),
                   n = as.vector (tm))
ggplot (dat, aes (x = distance, y = number)) +
    stat_binhex(aes(fill = log (..count..))) +
    scale_x_log10 (breaks = c (0.1, 0.5, 1, 2, 5, 10, 20),
                   labels = c ("0.1", "0.5", "1", "2", "5", "10", "20")) +
    scale_y_log10 (breaks = c (10, 100, 1000)) +
    scale_fill_gradientn(colours = c("seagreen","goldenrod1"),
                         name = "Frequency", na.value = NA) +
    guides (fill = FALSE)
```

![](/assets/blog-images/2017-10-17-bikedata/chicago.png)

What is the "average" distance travelled? The easiest way to calculate this is as a weighted mean,

``` r
tm <- as.vector (tm) / sum (tm)
sum (as.vector (dmat_ch) * tm, na.rm = TRUE)
```

    ## [1] 2.510698

The average trip distance is just over 2.5 kilometres. We could also compare differences in mean distances between male and female cyclists. Let's wrap this in a function so we can use it for even cooler stuff in a moment (and pretend that we don't care about calculating distance matrices each time just to keep the code simpler):

``` r
dmean <- function (bikedb = "bikedb", city = "chicago", gender = "f")
{
    tm <- bike_tripmat (bikedb = bikedb, gender = gender)
    tm <- as.vector (tm) / sum (tm)
    stns <- bike_stations (bikedb = bikedb, city = city)
    dm <- dodgr_dists (from = stns, to = stns)
    mean (as.vector (dm) * tm)
}
```

Differences in distances ridden between male and female cyclists can then be calculated with

``` r
dmean (gender = "f", dm = dmat)
dmean (gender = "m", dm = dmat)
```

    ## [1] 2.626591

    ## [1] 2.496609

And females cycle longer distances than males. (Do not at this point ask about statistical tests - these comparisons are made between millions (often tens of millions) of points, and statistical significance may always be assumed to be negligibly small.) Whatever the reason for this difference between genders, we can use this exact same code to compare equivalent distances for all cities (presuming the corresponding data to be present in the `bikedata` database):

``` r
cities = c ("london", "nyc", "chicago", "dc", "philly", "boston")
d_m <- d_f <- rep (NA, length (cities))
for (i in cities)
{
    d_m [i] <- dmean (city = i, gender = "m")
    d_f [i] <- dmean (city = i, gender = "f")
}
d_rel <- d_f / d_m
names (d_rel) <- cities
d_rel
```

And we thus discover that \[insert city\] manifests the greatest gender equality in terms of cycling distances, while \[insert city\] is the worst. The `bikedata` package (combined with `dodgr` and `osmdata`) enabled us to learn something about gender differences in human behaviour over a larger geographical scale than almost any other comparable data source.

visualisation
=============

Many users are likely to want to visualise how people use a given bicycle system, and in particular are likely to want to produce maps. This is readily done in conjunction with the ROpenSci packages `osmdata` for the street network and stplanr for mapping trip densities onto the network, as illustrated in the following code. First, extract the street network with osmdata:

``` r
library (magrittr)
xlims_la <- range (stns$longitude, na.rm = TRUE)
ylims_la <- range (stns$latitude, na.rm = TRUE)
# expand those limits slightly
ex <- 0.1
xlims_la <- xlims_la + c (-ex, ex) * diff (xlims_la)
ylims_la <- ylims_la + c (-ex, ex) * diff (ylims_la)
bbox <- c (xlims_la [1], ylims_la [1], xlims_la [2], ylims_la [2])
bbox <- c (xlims [1], ylims [1], xlims [2], ylims [2])
# Then the actual osmdata query to extract all OpenStreetMap highways
highways <- osmdata::opq (bbox = bbox) %>%
    osmdata::add_osm_feature (key = 'highway') %>%
    osmdata::osmdata_sp (quiet = FALSE)
```

The extract the geographical coordinates of the bike stations and re-project them onto the same projection as the street network.

``` r
stns_tbl <- bike_stations (bikedb = bikedb, city = "la")
stns <- sp::SpatialPointsDataFrame (coords = stns_tbl[, c('longitude',
                                                          'latitude')],
                                    proj4string = sp::CRS("+init=epsg:4326"),
                                    data = stns_tbl)
stns <- sp::spTransform (stns, highways$osm_lines@proj4string)
```

These data can then be used to create an `stplanr::SpatialLinesNetwork` which can be used to trace the routes between bicycle stations along the street network. This first requires mapping the bicycle station locations to the nearest nodes in the street network, and converting the start and end stations of the trip matrix to corresponding rows in the street network data frame.

``` r
a_net <- stplanr::SpatialLinesNetwork (sl = highways$osm_lines)
# Find the closest node to each station
nodeid <- stplanr::find_network_nodes (la_net, stns$longitude, stns$latitude)
# Convert start and end station IDs in trips table to node IDs in `la_net`
startid <- nodeid [match (ntrips$start_station_id, stns$stn_id)]
endid <- nodeid [match (ntrips$end_station_id, stns$stn_id)]
ntrips$start_station_id <- startid
ntrips$end_station_id <- endid
```

Finally, trips can be aggregated on each part of the network using the `stplanr::sum_network_lines()` function:

``` r
bike_usage <- sum_network_links (la_net, data.frame (ntrips))
```

The we're ready at last to plot our map, done here with the fabulous tmap package:

``` r
tmap::tm_shape (bike_usage, xlim = xlims, ylim = ylims, is.master = TRUE) +
    tmap::tm_lines (col = "numtrips", lwd = "numtrips",
                    title.col = "Number of trips",
                    breaks = c(0, 200, 400, 600, 800, 1000, Inf),
                    legend.lwd.show = FALSE, scale = 5) +
    tmap::tm_layout (bg.color = "gray95",
                     legend.position = c ("right", "bottom"),
                     legend.bg.color = "white",
                     legend.bg.alpha = 0.5)
```

What can be done better?
========================

The `bikedata` package has been developed to provide access to the data. Of course, being able to actually see the data, and particularly see them in map form, is simply cool. Yet the foregoing lines of code show that it is not currently straightforward. Plans are afoot to make this much easier, particularly via the forthcoming package [`dodgr`](https://github.com/mpadge/dodgr) for very rapid routing through street networks. Once released, `bikedata` will use this package to
